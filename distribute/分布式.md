# 分布式

## 1、分布式session

### 1.1 session复制

将一台机器上的Session数据广播复制到集群中其余机器上

### 1.2 session绑定

利用hash算法，比如nginx的ip_hash,使得同一个Ip的请求分发到同一台服务器上。

### 1.3 session服务器

利用独立部署的session服务器（集群）统一管理session，服务器每次读写session时，都访问session服务器。可使用redis等分布式数据库



## 2、分布式锁

### 2.1 数据排它锁

select ... for update

### 2.2  zookeeper

临时有序节点 curator；

判断自己是否为最小节点，不为最小节点则监听当前最小节点的删除事件

### 2.3 redis setnx+lua

存在锁丢失问题

### 2.4 redisson

向多台redis机器同时上锁，半数以上成功才成功，释放需要释放所有的锁;底层使用lua脚本



### 分布式锁续期问题

使用续期线程，一般1/3锁时间续期一次

但是续期ttl线程也会有问题：

1. ttl线程一直跑，业务线程假死，锁一直存在怎么办？
2. 续期失败，导致锁失效问题？
3. 发生GC时间较长，GC完成后锁已经失效，续期未能及时完成？
   通过上游系统熔断，重启系统



## 3、分布式id

### 3.1 UUID

### 3.2 数据库自增id

单点问题，性能问题

### 3.3 数据库多主模式

设置不用的初始值与步长；扩展麻烦

### 3.4 数据库号段模式

多主模式部署

mysql1将生成号段（1,1001]，自增的时候序列为1，3，4，5，7....

mysql1将生成号段（2,1002]，自增的时候序列为2，4，6，8，10...

### 3.5雪花算法

8字节，64位

![image.png](./image/雪花算法.png)

难点是机器id，原始的snowflake需要人工为每台机器指定一个机器id

### 3.6 百度（uid-generator） 美团（Leaf）

基于雪花算法；

workId 生产方式不同

Uid-generator: workId由数据库分配，应用启动往数据库表插入一条记录，成功后返回的该数据对应的自增唯一id就是该机器的wokId

leaf:workId是基本zookeeper的顺序id生成，启动时在zookeeper中生成一个顺序id

### 3.7 redis

incr 命令 实现自增

### 3.8 zookeeper顺序节点



